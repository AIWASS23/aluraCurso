Quando trabalhamos com React, podemos criar o projeto do zero, adicionando todos os arquivos necessários 
para trabalhar com essa biblioteca, ou podemos utilizar um único comando chamado de Create React App.

https://create-react-app.dev/

O comando create-react-app projeto --template typescript cria o projeto com a linguagem TypeScript.
O comando cd projeto entra na pasta desse projeto criado.
O comando npm start roda o projeto.

Com esse comando, estamos informando várias coisas, sendo elas:

npx:

O comando npx, diferente do comando npm, apenas executa um pacote, sem que precisemos instalá-lo na nossa 
máquina, como o create-react-app normalmente só é usado no começo para criar o projeto, o ideal é executar 
com npx pois isso fará com que você sempre execute a última versão do pacote.

create-react-app:

O nome do pacote que queremos executar.

projeto: 

O nome do projeto que queremos, assim como o nome da pasta.

--template typescript:

O Create React App nos permite usar vários templates, tendo como sintaxe o --template, que diz pro terminal 
que logo após iremos dizer qual template gostaríamos de usar, e o nome do template em si. 
O Create React App já tem o template typescript criado, mas caso tenha algum template que queira usar e 
não existe, você também pode criar o seu!

--use-npm:

Caso o yarn esteja instalado na sua máquina, o Create React App prioriza à utilização dele, e isso irá gerar 
um yarn.lock dentro da nossa aplicação, e nós queremos utilizar o npm ao invés do yarn, por isso precisamos 
usar o comando --use-npm se quisermos garantir que o Create React App utilize o npm para instalar as 
dependências necessárias e também garantir que ele gere o package-lock.json ao invés do yarn.lock.

comando completo:
npx create-react-app projeto --template typescript --use-npm

------------------------------------------------------------------------------------------------------------

Componentização

class Botao extends React.Component {
  render() {
   return (
      <button>
        Botão
      </button>
    )
 }
}

Nome do Componente:
O nome do componente deverá começar com letra maiúscula. Existe uma possibilidade no html de criar 
web-components, que nos permite criar tags html totalmente customizadas. Entre essas customizações, 
podemos customizar o nome da tag! Para o React diferenciar um componente de um web-component, ele pede para 
que criemos um componente com a primeira letra maiúscula, assim ele consegue diferenciar por exemplo 
que <meuBotao /> é um web-component e <MeuBotao /> é um componente!

https://developer.mozilla.org/pt-BR/docs/Web/Web_Components

return e JSX:

Para podermos criar um componente, fora a regra que citamos acima, precisamos retornar JSX. O JSX é uma forma 
de "escrever HTML no JS", que é a forma que explicamos, mas não é exatamente isso. O JSX não transforma o 
componente <Botao /> em HTML diretamente, antes disso, ele é transformado em uma elemento React, e aquele 
código é transformado em algo assim:

https://pt-br.reactjs.org/docs/introducing-jsx.html

const Botao = React.createElement('button', {}, 'Botão');

Sem se atentar ao que isso faz agora, mas por debaixo dos panos o React transforma aquela sintaxe 
"""HTML""" nesse palavrão que, na hora do ReactDOM.render, é transformado em DOM e, aí sim, transformado 
em HTML. A tag html é usada como primeiro parâmetro da função createElement como uma string? Isso mostra que, 
para criarmos um componente, precisamos de uma tag "pai", logo, o código a seguir não funcionará:

class Botao extends React.Component {
  render() {
   return (
      <p> Título do Botão </p>
      <button>
        Botão
      </button>
    )
 }
}

Caso você precise fazer isso, leia sobre React.Fragment.
https://pt-br.reactjs.org/docs/react-api.html#reactfragment

React.Component e render:

Para criarmos um componente com class components, precisamos estender à classe React.Component. 
Nesta classe, existe apenas uma função obrigatória chamada render e, dentro dela, nós retornamos o 
JSX que precisamos para criar o componente!

----------------------------------------------------------------------------------------------------

Com essa estrutura de arquivos:
components/
  botao/
    index.tsx
   Botao.module.scss

Com o CSS Modules já configurado na aplicação, conseguimos importar e utilizar o CSS Modules no 
arquivo index.tsx, sabendo que dentro de Botao.module.scss existe uma classe botao com o codigo:

import style from './Botao.module.scss';

<button className={style.botao}> … </button>

Podemos importar o CSS Modules de várias formas diferentes. Ou que podemos utilizar vários módulos no 
mesmo componente. O CSS Modules é bem mais complexo e interessante do que imaginamos e, se irmos bem a 
fundo nessa tecnologia, podemos deixar o nosso código bem mais interessante.

O CSS Modules nos dá o CSS em formato object e os exporta como default, logo, podemos importar das seguintes 
formas:

import style from './NomeDoComponente.module.scss';

import * as style from './NomeDoComponente.module.scss';

import { default as style } from './NomeDoComponente.module.scss';

Ainda seguindo em como importar um CSS Module, como ele é um export default, podemos nomeá-lo da 
forma como bem entendermos, por exemplo:

import Foo from './NomeDoComponente.module.scss';

import Bar from './NomeDoComponente.module.scss';

import Banana from './NomeDoComponente.module.scss'

Como agora sabemos que podemos nomear o objeto de formas diferentes, podemos também importar vários 
CSS Modules em um só componente!

import BotaoStyle from './Botao.module.scss';
import ItemStyle from './Item.module.scss';

OBS: Todas essas formas citadas acima não são específicas de como importar um CSS Modules, 
e sim de como importar um export default em JS.

https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/

Transformando CSS em CSS Modules

Para transformar o arquivo src/components/Botao/style.scss em CSS Modules trocando o nome do arquivo .scss 
para o nome do componente, instalando o plugin typescript-plugin-css-modules como dependência de 
desenvolvimento e configurando o plugin dentro do arquivo tsconfig.json e importando a classe dentro do 
arquivo de forma correta dentro de src/components/Botao/index.tsx.

Dentro do terminal:
npm install -D typescript-plugin-css-modules

Dentro de tsconfig.json:

{
  "compilerOptions": {
     …
    "plugins": [{ "name": "typescript-plugin-css-modules" }]
  }
}

Mudar o arquivo src/components/Botao/style.scss para src/components/button/Botao.module.scss

Dentro do arquivo src/components/Botao/index.tsx:

import React from 'react';
import style from './Botao.module.scss;

class Botao extends React.Component {
  render() {
    return (
      <button className={style.botao}>
        Botão
      </button>
    )
  }
}

export default Botao;

Com o CSS Modules, a classe que seria apenas botao, será {nomeDoArquivoCSS}_{nomeDaClasseCSS}__{hashAleatoria}. 
É por isso que mudamos nosso arquivo de style.scss para Botao.module.scss, pois isso faz ficar mais evidente 
na hora da classe que essa classe vem do componente Botao, fazendo a própria classe ser auto documentada, 
pois sabemos que é a classe botao vindo do componente Botao.

-------------------------------------------------------------------------------------------------------------

Adicionando Props para o Botão


Troque o texto padrão do componenteBotão dentro de src/components/Botao/index.tsx por um 
prop children que terá o texto a ser exibido no componente.

Dentro de src/components/Botao/index.tsx:

import React from 'react';
import style from './Botao.module.scss';

class Botao extends React.Component {
  render() {
    return (
      <button clasName={style.botao}>
        {this.props.children}
      </button>
    )
  }
}

export default Botao;

Dessa forma, podemos utilizar o componente Botao de forma bem parecida como utilizamos uma tag nativa HTML:

<Botao>
  Meu botão!
</Botao>

O React disponibiliza essa prop especial children por padrão para que possamos utilizar o componente dessa 
forma!

Sobre Keys (Chaves no React)

Lembra que os componentes React são criados utilizando JSX não HTML? Então, usando o mesmo processo, 
o React não cria um DOM, e sim um VDOM (Virtual DOM). Não entraremos em detalhes neste curso sobre Virtual DOM, 
porém saiba que o React cria um DOM virtual em memória e só atualiza o DOM real quando algo dentro desse 
Virtual DOM realmente é atualizado. Levando isso em consideração, como o React saberia qual seria a cópia no 
Virtual DOM do item 45 em um array de 50 itens, por exemplo? Ou pior, se o item 47 for removido, como ele 
vai saber que o item 48, 49 e 50 não foram atualizados? E os outros? Para isso o React utiliza a propriedade 
key, que nada mais é que uma chave(AHÁ!) para linkar o item no Virtual DOM no DOM real, por isso não vemos a 
prop sendo passada para o componente Item, pois essa prop é algo interno no React que não tem utilidade para 
nós. Por isso também não é recomendado que se utilize o index do array como key, pois caso o array mude, 
a possibilidade de vários itens desse array serem atualizados sem necessidade é imensa!

https://pt-br.reactjs.org/docs/lists-and-keys.html#keys

--------------------------------------------------------------------------------------------------------------------

https://www.youtube.com/watch?v=ZZoB5frlcnE
https://www.reactivemanifesto.org/pt-BR

-------------------------------------------------------------------------------------------------------------

Passando selecionaTarefa via Props:

Dentro de src/pages/App.tsx:
…
function App(){
  …

  function selecionaTarefa() {

  }
  return (
    …
    <Lista
      …
      selecionaTarefa={selecionaTarefa}
    />
  )
}
Dentro de src/components/Lista/index.tsx:

…
interface Props {
  selecionaTarefa: (tarefaSelecionada: ITarefa) => void
}

function Lista() {
  return (
    …
    <Item
      …
      selecionaTarefa={selecionaTarefa}
    />
  )
}

Dentro de src/components/Lista/Item/index.tsx:

interface Props extends ITarefa {
  selecionaTarefa: (tarefaSelecionada: ITarefa) => void
}

export default function Item({ …, selecionaTarefa}: Props) {
  …
}

Podemos ver 2 coisas interessantes, a primeira é como tipar uma função e a segunda é como herdar tipos de 
interfaces.

Como tipar uma função:
Coloque uma arrow function dentro dos parênteses, temos que dizer quais parâmetros essa função pode receber 
e após o sinal de => temos que dizer que tipo ele retorna, ou se não retornar nada é do tipo void, 
ficando assim:

selecionaTarefa: (tarefaSelecionada: ITarefa) => void

Podemos ler essa linha de código como "selecionaTarefa é uma função que aceita o parâmetro 
tarefaSelecionada do tipo ITarefa e não retorna". Uma curiosidade sobre o nome do parâmetro é que o nome na 
tipagem não precisa ser o mesmo nome da função original, posso chamar do que eu quiser aqui, mas para ser 
legível mantivemos o mesmo nome.

Herdar tipos de interfaces:

Utilizando o extends podemos herdar todos os tipos de uma interface em outra interface, ou seja:

interface ITarefa {
  tarefa: string,
  tempo: string
}

interface Props extends ITarefa {
  selecionaTarefa: (tarefaSelecionada: ITarefa) => void
}

Seria o mesmo de:

interface Props {
  tarefa: string,
  tempo: string,
  selecionaTarefa: (tarefaSelecionada: ITarefa) => void
}

Funções importantes dentro do React com Javascript:

O map é um método MUITO importante, pois como no React existe essa combinação grandiosa entre reaproveitamento
de código e renderização dinâmica, o map é o método perfeito para isso, pois você consegue iterar sobre todos 
os itens e retornar alguma coisa no mesmo index que está sendo iterado no laço atual, ou seja:

const tecnologias = ['React', 'Typescript', 'Javascript'];
Se você faz isso daqui:

const tecnologiasComJSX = tecnologias.map(tecnologia => <li> {tecnologia} </li>)

Nesse caso, a variável tecnologiasComJSX será [<li> React </li>, <li> Typescript </li>, <li> Javascript </li>]

Com isso transformamos todos os itens deste array em JSX.

Spread Operator:

O Spread Operator é muito importante para fazer atualizações em estados, pois quando queremos atualizar 
estados, é comum termos parte do estado que não será alterado, veja esse caso:

let curso = {
  instrutor: "Luiz Fernando",
 curso: "React com Typescript"
}

Caso queiramos adicionar o ano em que o curso foi lançado, podemos fazer isso:

curso = {
  …curso,
  ano: 2021
}

Esse ...curso dentro das chaves significa que dentro daquele novo objeto que está sendo criado terá tudo que 
curso tinha e o ano que faltava, ficando assim:

{
  instrutor: "Luiz Fernando",
  curso: "React com Typescript",
  ano: 2021
}

ternaries:

Ternários são bem importantes para a parte renderização condicional do React, pois ele permite que consigamos 
renderizar JSX de forma condicional, adicionar classes de forma condicional, mudar estados de forma 
condicional, entre outros.

Exemplo de ternário em JSX
return (
  <>
    {condicao ?
      <p> Atende a condição </p>
    :
      <p> Não atende a condição </p>
    }
  </>
)

Nesse caso dou uma menção ao operador &&, que nos permite renderizar de forma condicional também, mas sem a 
necessidade do :, ou seja, de um else:

return (
  <>
    {condicao &&
      <p> Esse JSX só vai renderizar se a condição for verdadeira </p>
    }
  </>
)

Exemplo de ternário em classes CSS:

return (
 <button className={condicional ? "classe-com-condicional" : "classe-sem-condicional"}>
    Meu botão
  </button>
)

Exemplo de ternário em mudança de estado:

const [curso, setCurso] = useState({ nome: "React com Typescript", completado: false });
…
setCurso({
  nome: "React com Typescript",
  completado: false,
  completado: condicao ? true : false
})

destructuring:

O destructuring é muito útil para podermos aproveitar estados anteriores e mudarmos alguma coisa, vamos 
escrever o exemplo acima:

const [curso, setCurso] = useState({ nome: "React com Typescript", completado: false });
…
setCurso({
  …curso,
 completado: condicao ? true : false
})

---------------------------------------------------------------------------------------------------------


