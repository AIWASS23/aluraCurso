https://www.figma.com/file/c3RarCwq533GF1rrTRQEES/Sorteador-de-amigo-secreto?node-id=35%3A134
https://www.alura.com.br/artigos/o-que-e-reset-css?_gl=1*1w4ji7e*_ga*MTc5MDYxNjI1NC4xNjc0MzI0MTQ5*_ga_59FP0KYKSM*MTY4ODY2MjEyNC43OS4xLjE2ODg2NjMwNDcuMC4wLjA.*_fplc*OVllb1EzN1FJOGNPajJTRlRlclVVaHFLRmNTSzFrRUZYT1BMUEFjRGk5NVppUHNYJTJCZHlTeDFKa1RiNlh2SDhCd1FzaWh3WDhCMWpTd2VyWTF5WFMwMyUyRiUyRnFyayUyRm55RFlVRDR4JTJCc01nNExuSTFxYU85SDAlMkJLdnFIU1ZXQzZBJTNEJTNE

Formas de estilizar componentes React:

https://styled-components.com/
https://emotion.sh/docs/@emotion/react
https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/

TDD:

O Desenvolvimento Orientado a Testes, é uma abordagem de desenvolvimento de software em que os testes 
automatizados são criados antes da implementação do código em si. O processo consiste em seguir um ciclo 
curto e repetitivo de três etapas: escrever um teste, implementar o código mínimo necessário para que o 
teste seja aprovado e refatorar o código para melhorar sua qualidade. O TDD enfatiza a criação de testes 
automatizados como uma prática fundamental para guiar o desenvolvimento do software. Ao escrever os testes 
primeiro, o desenvolvedor precisa pensar na funcionalidade desejada e nos casos de uso antes de escrever 
o código real. Essa abordagem ajuda a definir claramente o comportamento esperado do software antes de 
começar a implementá-lo, o que pode levar a um design de código mais limpo e modular.

-----------------------------------------------------------------------------------------------------------

Roles - Porque acessibilidade conta!

Realizar as buscas pelas roles é uma boa prática porque, além de testar a sua aplicação, você garante a 
sua acessibilidade. As especificações relacionadas à acessibilidade estão definidas na W3C 
(World Wide Web Consortium) como WAI-ARIA. WAI-ARIA quer dizer Accessible Rich Internet Applications 
(Aplicações Ricas para uma Internet Acessível). O conjunto ARIA oferece a maneira de tornar as aplicações 
mais acessíveis a uma maior diversidade de pessoas, incluindo quem utiliza tecnologias assistivas, como 
leitores de telas e lentes de aumento.

https://www.w3.org/TR/wai-aria-1.1/#role_definitions

------------------------------------------------------------------------------------------------------------

Snapshot test:

O teste de snapshot, também conhecido como teste de captura de estado, é uma técnica de teste de software 
que visa verificar se o estado atual de um componente ou sistema corresponde ao estado esperado 
previamente registrado. No contexto do desenvolvimento de software, um snapshot é uma representação 
estática de um objeto, componente ou sistema em um determinado momento. Esse snapshot é geralmente 
capturado durante a execução de testes iniciais, quando o sistema está em um estado conhecido e correto. Ao 
realizar um teste de snapshot, o objetivo é comparar o estado atual do componente ou sistema com o 
snapshot previamente registrado. Se houver uma diferença entre o estado atual e o estado esperado, o teste 
falhará, indicando que algo mudou desde a captura do snapshot original. A principal vantagem do teste de 
snapshot é que ele pode ajudar a identificar regressões, ou seja, mudanças não intencionais que ocorreram 
no código e que afetam o estado esperado do sistema. Isso é particularmente útil em cenários onde as 
mudanças são frequentes, como em projetos de desenvolvimento ágil, pois permite detectar alterações 
indesejadas e corrigi-las antes que causem problemas mais graves. No entanto, é importante ressaltar que o 
teste de snapshot não é adequado para todos os tipos de testes. Ele é mais comumente usado em testes de 
integração ou testes de unidade para componentes isolados. Além disso, o teste de snapshot pode ser 
sensível a mudanças de menor importância, como diferenças de formatação ou de dados exatos, o que pode 
levar a falsos positivos. Portanto, é fundamental utilizar o teste de snapshot como uma ferramenta 
complementar aos outros métodos de teste e considerar suas limitações e necessidades específicas de cada 
projeto.

-------------------------------------------------------------------------------------------------------

O Jest é uma biblioteca muito conhecida no mundo dos testes e nos oferece várias expectativas já prontinhas 
para serem utilizadas. Além dessas, você tem também todo o complemento do jest-dom, como por exemplo o 
toBeInTheDocument. E tenha em mente que, se o teste está muito grande ou difícil demais de ser implementado, 
talvez exista espaço para refatorar o código atual e decompor o componente em componentes menores.

https://jestjs.io/pt-BR/docs/expect
https://github.com/testing-library/jest-dom

----------------------------------------------------------------------------------------------------------

Publicação na web:
https://vercel.com

---------------------------------------------------------------------------------------------------------

Outras formas de buscar elementos

Focamos nas boas práticas da React Testing Library e utilizamos roles para buscar os elementos HTML. 
Porém, essa não é a única forma de realizar buscas no DOM. Aqui estar algumas que você pode precisar, mas 
não deixe de conferir a documentação se precisa de algo mais específico.

https://testing-library.com/docs/queries/about

Esse são os tipos de consultas (em inglês, queries) disponíveis, de acordo com a quantidade de elementos 
que você espera:

Buscando elementos únicos:

getBy
queryBy
findBy

Buscando múltiplos elementos:

getAllBy
queryAllBy
findAllBy

Consultas específicas:

ByRole:

getByRole
queryByRole
getAllByRole
queryAllByRole
findByRole
findAllByRole

Quando conseguimos encontrar elementos por sua role, significa que leitores de tela também serão capazes, 
e a aplicação estará acessível.

ByLabelText:

getByLabelText
queryByLabelText
getAllByLabelText
queryAllByLabelText
findByLabelText
findAllByLabelText

É uma alternativa quando, por exemplo, temos múltiplos inputs no mesmo componente. Nesse caso, podemos 
buscar o input pelo label associado a ela. Confira a seguir boas práticas para esse cenário:

<label for="email-input">E-mail</label>
<input id="email-input" />

<label id="email-label">E-mail</label>
<input aria-labelledby="email-label" />

<label>E-mail <input /></label>

<label>
  <span>E-mail</span>
  <input />
</label>

<input aria-label="E-mail" />

Em qualquer um dos exemplos acima, podemos obter o input da seguinte forma:

const inputEmail = screen.getByLabelText(‘E-mail’)

ByPlaceholderText:

getByPlaceholderText
queryByPlaceholderText
getAllByPlaceholderText
queryAllByPlaceholderText
findByPlaceholderText
findAllByPlaceholderText

Aqui, estamos falando do atributo do html, que também podemos utilizar para buscar os elementos:

<input placeholder="E-mail" />

E para buscar:

const inputEmail = screen.getByPlaceholderText(‘E-mail’)

ByText:

getByText
queryByText
getAllByText
queryAllByText
findByText
findAllByText

Agora, estamos falando do textContent dos elementos HTML. Então, para buscar uma âncora com essa marcação:

<a href="/sobre">Marcelo</a>

Escrevemos:

const ancoraSobre = screen.getByText(‘Marcelo’)

É comum também o uso de Expressões Regulares para fazer buscas por texto. 

ByDisplayValue:

getByDisplayValue
queryByDisplayValue
getAllByDisplayValue
queryAllByDisplayValue
findByDisplayValue
findAllByDisplayValue

Podemos utilizar essa query para encontrar elementos do tipo input, textarea, ou select.

O “display value” é o valor em si do elemento.

Se liga aqui no exemplo:
<input type="text" id="nome" value=’'Agarikov'’ />

Agora com o valor preenchido, podemos realizar a query:

const nomeInput = screen.getByDisplayValue('Agarikov’)

ByTestId:

getByTestId
queryByTestId 
getAllByTestId
queryAllByTestId
findByTestId
findAllByTestId

Quando tudo mais falhar, podemos definir um atributo data-testid no elemento e utilizar esse tipo de 
query para encontrá-lo:

<div data-testid="id-customizado" />

const elemento = screen.getByTestId(‘id-customizado')

Mas fique atento a isto, pois aqui estamos sem valor semântico nenhum. Isso prejudica leitores de tela e 
demais softwares de acessibilidade.

