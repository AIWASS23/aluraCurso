Regex, ou expressões regulares, é uma linguagem para encontrar padrões de texto. Sendo 
uma linguagem independente, existem interpretadores para a maioria das plataformas de 
desenvolvimento, como JavaScript, C#, Python ou Ruby.

Uma classe de caracteres predefinida é \d, que significa qualquer dígito.

Existem vários meta-char, como . ou *.

Existem quantifiers que definem quantas vezes um caractere deve aparecer:
- {1} é um quantifier que significa uma vez.
- * é um quantifier que significa zero, uma ou mais vezes
- . é um meta-char que significa qualquer char.
- Com \ podemos escapar meta-chars, por exemplo \..

-------------------------------------------------------------------------------------------

Podemos definir facilmente a classe de qualquer caractere com o [A-Z].
Conhecemos todos os quantifiers como ?, +, * e {n}.
\s significa whitespace e é um atalho para [ \t\r\n\f].
\w significa word char e é uma atalho para [A-Za-z0-9_].

--------------------------------------------------------------------------------------

Existem âncoras predefinidas que selecionam uma posição dentro do alvo.
\b é uma âncora que seleciona um word boundary, isso é o início ou fim da palavra.
^ é uma âncora que seleciona o início da string alvo.
$ é uma âncora que seleciona o fim do alvo.

---------------------------------------------------------------------------------------------

http://www.goulart.pro.br/cbasico/Calculo_dv.htm
http://www.cjdinfo.com.br/utilitario-calculo-digito-modulo-11

Regex Email

A regex usa âncoras no início ^ e fim $ para garantir o match inteiro;

Antes do @, temos: 
^([\w-]\.?)+

Definimos uma classe com word-chars e hífen, seguido por um ponto opcional: 
[\w-]\.?

Dessa classe pode se repetir uma ou mais vezes, então criamos um grupo e + ao final: 
([\w-]\.?)+

Depois do @, temos:
- ([\w-]+\.)+, que é bastante parecido com o anterior ao @, porém com o . obrigatório,
- ([A-Za-z]{2,4})+$, 

que é o final da nossa regex, seleciona o domínio do email, como br, com, us. 
O mínimo de letras dessa parte final devem ser 2 e no máximo 4.

Regex Endereço

A dica para a criação de regex é sempre ir passo-a-passo. Por isso, vamos analisar o seguinte padrão, sempre lembrando de agrupar e de adicionar o pipe ao final:
Nome|data/de/nascimento|Rua onde mora|numero|cep|Cidade

Nome era necessário capturar, então iremos criar um grupo:
([\w\s]+)\|

Data de nascimento não era necessário, por isso, deixaremos esse grupo como non-capturing group:
(?:\d\d\/\d\d\/\d\d\d\d)\|

Rua Onde Mora é necessário capturar, e por isso, criamos um grupo normal: 
([\w\s]+)\|

Número é necessário capturar, portanto:
(\d{1,4})\|

CEP é necessário capturar, e podemos criar um grupo dessa maneira: 
(\d{5}-\d{3})\|

Cidade é a nossa última análise, e não é necessária. Portanto, basta adicionarmos ?: 
para deixar o seu grupo não-capturável: (?:[\w\s]{10,})

Resultado: 
^([\w\s]+)\|(?:\d\d\/\d\d\/\d\d\d\d)\|([\w\s]+)\|(\d{1,4})\|(\d{5}-\d{3})\|(?:[\w\s]{10,})$

Declaramos um grupo com ().
Podemos ter grupos e subgrupos.
Grupos são retornados na hora de executar, e são úteis para selecionar uma parte do match.
Através do ?:, dizemos que não queremos ver esse grupo na resposta.

------------------------------------------------------------------------------------------------

quantifiers são gananciosos por padrão e que podemos utilizar um ? logo após o 
quantifier, deixando-o preguiçoso. Também aprendemos como podemos referenciar o texto 
de um grupo dentro da regex, aonde n é o número do grupo.

------------------------------------------------------------------------------------------

No caso do JavaScript, podemos usar o próprio console do navegador para testar nossas 
expressões. Abra o console do seu navegador favorito (eu uso Chrome, e você?) e declare 
a seguinte variável:

var target = "11a22b33c";
Declaramos a variável target que é o alvo, ou seja, o conteúdo no qual aplicaremos a 
expressão regular. Em JavaScript, podemos declarar uma expressão regular de duas 
maneiras. A primeira forma consiste em criarmos uma instância de RegExp:

var exp = new RegExp('(\\d\\d)(\\w)', 'g');
Veja que RegExp recebe uma string, mas o que a torna verbosa é que precisamos escapar 
cada \ colocando um barra extra! Além disso, o segundo parâmetro indica que queremos 
todas as ocorrências encontradas da nossa expressão, não apenas a primeira que encontrar.

Podemos usar a forma literal, menos verbosa, Nela,colocamos nossa expressão entre /:
exp = /(\d\d)(\w)/g;
Veja que dessa forma não foi necessário colocar, por exemplo, \\d, apenas \d e nem \\w, 
apenas \w. E para testar nossa expressão?

exp.test(target);

Veja que uma expressão regular criada possui o método test que recebe o alvo no qual 
ela será aplicada. Ela retornará true apenas se o alvo seguir o padrão da expressão. 
Ótimo, mas se quisermos obter como resultado as partes do alvo, que atendem à nossa 
expressão regular? Nesse caso, usamos o método exec:

exp.exec(target);
Ela imprimirá no console:

["11a", "11", "a"]

É um array, no qual o primeiro item é o match, ou seja, a parte do nosso alvo que 
condiz com nossa expressão. Contudo, precisamos executar mais uma vez nossa expressão 
para que ele encontre o próximo match. Precisamos fazer até que o resultado final seja 
null, ou seja, quando não houver mais match:

exp.exec(target);
    ["22b", "22", "b"]
exp.exec(target);
    ["33c", "33", "c"]
exp.exec(target);
    null    
Contudo, você deve estar se perguntando o que são os outros dois elementos do array. 
O primeiro já sabemos, que é a parte do target que atendeu nossa expressão regular. 
Os demais parâmetros equivalem ao padrão que colocamos para cada () da nossa expressão. 
Usamos dois (), se tivéssemos usando cinco, teríamos no lugar de dois itens, cinco itens.

http://regexr.com/
https://regex101.com/