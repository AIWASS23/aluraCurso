ESLint

Para “chamar” o Eslint no VSC e organizar seu código automaticamente, utilize o atalho ctrl + shift + P 
(Windows/Linux) ou cmd + shift + P (MacOs), digite Eslint e escolha a opção "Fix all auto-fixable 
problems" ou posicione o cursor piscante sobre alguma das linhas sublinhadas vermelhas e utilize o atalho 
ctrl + . para abrir o menu do Eslint e escolher “Fix all auto-fixable problems” se estiver disponível.

https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint
https://eslint.org/
https://www.npmjs.com/package/eslint

Tipos de testes:

Testes estáticos:
- Voltados para analisar o código sem necessariamente executá-lo, verificando se algumas boas práticas e 
formatação padronizada foram adotadas na implementação;

Testes unitários 
- São utilizados para verificar o comportamento das menores unidades de código da aplicação;

Testes de integração:
- São as fases do teste de software em que módulos são combinados e testados como um conjunto;

Teste E2E (End-to-End): 
- É um método de teste utilizado para testar um fluxo da aplicação desde o começo até o fim.

-----------------------------------------------------------------------------------------------------

Assert nativo do Node.js

O próprio Node.js já nos oferece uma forma nativa de fazer asserções. A asserção de igualdade pode ser 
feita utilizando o método assert.strictEqual(atual, esperado, mensagem). Ou seja, podemos passar 2 
parâmetros que serão comparados e uma mensagem opcional para ser mostrada caso eles sejam diferentes.

https://nodejs.org/api/assert.html#assert

Jest com ESM

https://jestjs.io/pt-BR/docs/ecmascript-modules
https://jestjs.io/pt-BR/docs/configuration
https://jestjs.io/pt-BR/docs/manual-mocks

Cobertura de testes

File
A primeira coluna indica quais arquivos de teste do diretório estão sendo executados. Cada linha dessa 
coluna fornece as estatísticas para cada arquivo de teste localizado e executado pelo Jest.

Stmts
Esta coluna lista a porcentagem de statements do código que foram cobertos pelos testes. Em programação, 
um statement (ou declaração) é cada comando individual que damos ao programa para que ele execute 
instruções.

Branch
Sempre que o código de um programa apresenta ramificações no fluxo, por exemplo, blocos if…else ou switch, 
devemos garantir que todas as possibilidades sejam testadas. Ou seja, se existe um bloco if…else no 
programa, devemos escrever testes tanto para o código executado no bloco if quanto para o código executado 
no bloco else, e a porcentagem na coluna Branch mostra em quais arquivos há ramificações que precisam 
ter todas as suas condições testadas. Embora tenham o mesmo nome, não confundir estas branches com 
branches de versionamento do Git. O Jest não acessa o repositório do Git e nem há nenhum teste a ser 
feito nesse sentido.

Funcs
Informa qual a porcentagem de funções presentes em cada arquivo que foram executadas/chamadas pelos testes.

Lines
A porcentagem de linhas de código por onde os testes passaram durante a sua execução. Quando está em 100%, 
significa que os testes percorreram todas as linhas de código dos arquivos testados. Quando não está em 
100%, devemos observar a coluna seguinte (Uncovered Lines), que vai indicar por quais linhas o Jest não 
passou ao executar os testes nos arquivos.

Uncovered lines
Lista quais linhas de cada arquivo não foram percorridas pelo Jest. Você pode usar esta lista para 
consultar o código e pensar em quais testes podem ser adicionados para que estas linhas também sejam 
“cobertas”.

O Jest também fornece o relatório de cobertura de forma mais visual. Quando utilizamos a flag coverage, 
além de exibir o relatório no terminal, o Jest também cria a pasta coverage na raiz do projeto. Dentro 
desta pasta, você pode acessar a subpasta lcov-report para ver o relatório (report) e interagir com os 
arquivos, abrindo o arquivo index.html e navegando pelos arquivos.

---------------------------------------------------------------------------------------------------------

funções adicionais

O framework Jest apresenta diversas funcionalidades para tornar o desenvolvimento de testes unitários mais 
eficiente. Pensando nisso, o uso de matchers é interessante para comparar valores e permite a construção 
de asserções no seu código.

https://jestjs.io/pt-BR/docs/getting-started
https://jestjs.io/pt-BR/docs/expect

Método	                                   |      Funcionalidade
-----------------------------------------------------------------------------------------------------------
expect(value)                              | Testar um valor
-----------------------------------------------------------------------------------------------------------
expect.extend(matchers)                    | Adicionar seus próprios "matchers"
-----------------------------------------------------------------------------------------------------------
expect.anything()                          | Corresponde a qualquer coisa menos null e Undefined
-----------------------------------------------------------------------------------------------------------
expect.any(constructor)                    | Testa qualquer coisa que é criada com um construtor
-----------------------------------------------------------------------------------------------------------
expect.arrayContaining(array)              | O array esperado é um subconjunto do array recebido
-----------------------------------------------------------------------------------------------------------
expect.assertions(número)                  | Verifica que um certo número de verificações são chamadas 
                                           | durante um teste.
-----------------------------------------------------------------------------------------------------------
expect.closeTo(number, numDigits?)         | É útil quando você compara números quebrados num array.
-----------------------------------------------------------------------------------------------------------
expect.hasAssertions()                     | Verifica que pelo menos uma verificação é chamada durante 
                                           | um teste.
-----------------------------------------------------------------------------------------------------------
expect.not.arrayContaining(array)	       | Quando o array esperado não é um subconjunto do array recebido
-----------------------------------------------------------------------------------------------------------
expect.not.objectContaining(object)        | Quando o objeto esperado não é um subconjunto do objeto 
                                           | recebido.
-----------------------------------------------------------------------------------------------------------
expect.not.stringContaining(string)	       | Quando o valor recebido não é uma String ou não corresponde 
                                           | ao valor esperado da String.
-----------------------------------------------------------------------------------------------------------
expect.not.stringMatching(string / regexp) | Quando o valor recebido não é String ou não corresponde a 
                                           | String esperada ou a expressão regular.
-----------------------------------------------------------------------------------------------------------
expect.objectContaining(object)	           | Corresponde a qualquer objeto recebido que recursivamente 
                                           | coincide com as propriedades esperadas
-----------------------------------------------------------------------------------------------------------
expect.stringContaining(string)	           | Quando o valor recebido é uma String que contém a 
                                           | String esperada.
-----------------------------------------------------------------------------------------------------------
expect.stringMatching(string / regexp)     | Quando o valor recebido é uma String que contém a String ou 
                                           | expressão regular esperada.
-----------------------------------------------------------------------------------------------------------
expect.addSnapshotSerializer(serializer)   | Para adicionar um módulo que formata estruturas de dados 
                                           | específicas da aplicação.
-----------------------------------------------------------------------------------------------------------
.not                                       | Se você sabe como testar algo, .not permite que você teste 
                                           | seu oposto.
-----------------------------------------------------------------------------------------------------------
.resolves                                  | Decodifica o valor de uma promessa cumprida, para que 
                                           | qualquer outro matcher possa então ser encadeado.
-----------------------------------------------------------------------------------------------------------
.rejects                                   | Decodifica o motivo de uma promessa rejeitada, para que 
                                           | qualquer outro matcher possa ser encadeado
-----------------------------------------------------------------------------------------------------------

Matchers

O Jest utiliza funções chamadas de matchers (em português, algo como “combinadoras”), que servem para 
verificar e comparar resultados esperados e recebidos nos testes - ou seja, essas funções verificam se os 
resultados “combinam” entre si. Existe uma variedade de matchers, cada qual para uma finalidade diferente.

Os matchers podem ser do tipo:

Comuns: usados para testar igualdade de valores de forma exata;

Veracidade: usados para distinguir de forma explícita entre undefined, null e false;

Number: usados para comparar números equivalentes;

String: usados para verificar expressões regulares;

Arrays e iteráveis: usados para verificar a inclusão de um item em um array ou iterável;

Exceções: usado para testar se uma função lança um erro quando chamada;

https://jestjs.io/docs/using-matchers

-----------------------------------------------------------------------------------------------------------

Ferramentas para API

Algumas formas de realizar os testes sem precisar de um Front-End, e uma delas é através do próprio 
terminal. No entanto, esse processo é muito verboso e custoso, pois demanda muito tempo. Pensando então 
em otimizar e facilitar os testes, há diversas ferramentas e plataformas que apresentam essas 
especialidades.

Postman

A ferramenta Postman é uma API Client e funciona simulando as requisições feitas no lado do cliente, ou 
seja, você não precisa de um front para testar requisições e ainda pode automatizar os testes.

https://www.postman.com/

Insomnia

Apresenta uma aparência mais “simples” e tem o mesmo papel que o Postman. Também é amplamente utilizado 
pela comunidade dev. É uma ferramenta gratuita.

https://insomnia.rest/download

Thunder Client

Uma ferramenta como Postman ou Insomnia direto no VSCode. O Thunder Client é leve, intuitivo e se 
consolida como uma boa opção para quem deseja simplicidade e rapidez na hora de testar seus projetos.

https://www.thunderclient.com/

Funções Assincronas
https://www.alura.com.br/artigos/async-await-no-javascript-o-que-e-e-quando-usar?_gl=1*tij7dc*_ga*MTc5MDYxNjI1NC4xNjc0MzI0MTQ5*_ga_59FP0KYKSM*MTY4ODgzNDAzOS44MS4xLjE2ODg4NDE2MDYuMC4wLjA.*_fplc*aUI4akc3YnZBcXpYTnFCT3hlR0xxZyUyRnpPN0JlQ0hMMmp4Y0FUZiUyRmltQWIwazZ6MFZUTEl3dWpKVHV2JTJCciUyQnlMWiUyRmh1WCUyRkRHdWI0cjVjRDUwQUFDMk0lMkYyY3l2S0xwRWl4eTlMc1hNZ0wyYW5DdWp4cDl5RUhvaWs5MnE0T1ElM0QlM0Q.

Escopos de pacotes

O uso do @ nem sempre é presente nas instalações de pacotes NPM. Chamamos essa nomenclatura de escopo. 
Imagine que ao configurar um nome e publicar um pacote NPM, o escopo permite que você crie um pacote com o 
mesmo nome que outros pacotes criados por usuários diferentes sem conflitos. Quando listados como 
dependentes em um arquivo package.json, os pacotes com escopo são precedidos por seu nome de escopo. 
O nome do escopo é tudo entre o “@” e a barra e você pode separar pacotes públicos (NPM) e privados 
(NPMCorp) adicionando o prefixo de escopo:

Escopo "npm": @npm/nome-do-pacote
Escopo "npmcorp": @npmcorp/nome-do-pacote

Sendo assim, quando precisamos instalar um pacote NPM basta usar o “@” para diferenciar o pacote com ou 
sem escopo.

Para pacotes com escopo, execute npm install <@escopo/nome-do-pacote>
Para pacotes sem escopo, execute npm install <nome-do-pacote>

Escopo de pacotes públicos:

Nem todo pacote público tem escopo, e, por padrão, pacotes privados sempre têm escopo. Mas é possível 
compartilhar seu código publicamente em um namespace de usuário ou organização e você pode publicar 
pacotes públicos com escopo de usuário ou de organização no registro NPM.

https://docs.npmjs.com/creating-and-publishing-scoped-public-packages

Escopo de pacotes privados:

É possível usar o registro NPM para hospedar código que é visível apenas para você e colaboradores 
escolhidos, permitindo que você gerencie e use código privado junto com código público em seus projetos. 
O serviço do NPM tem a capacidade de hospedar pacotes privados. Porém, esse serviço não é gratuito e 
requer pagamentos mensais. 

https://docs.npmjs.com/about-private-packages
https://docs.npmjs.com/creating-and-publishing-private-packages

------------------------------------------------------------------------------------------------------------
Hooks

Alguns métodos do Jest que controlavam eventos em alguns momentos específicos, como por exemplo antes de 
cada teste acontecer ou após todos os testes. Chamamos este tipo de função de hook (algo como “gancho” em 
português). As funções hook não são exclusivas do Jest ou mesmo do JavaScript, e sim um conceito utilizado 
em programação no geral. Chamamos de hook uma função ou método que é chamado quando queremos dar ao 
programa um comportamento específico em alguma determinada circunstância - por exemplo, antes, durante ou 
depois de determinado código ser executado.

https://jestjs.io/pt-BR/docs/setup-teardown
https://jestjs.io/pt-BR/docs/api


spyOn vs jest.fn()

Podemos utilizar jest.fn() quando a implementação original da função - ou seja, o código que ela executa 
- não é importante para o teste, e pode ser substituída pelo que definimos durante o teste, normalmente 
retornando um objeto.

No caso de jest.spyOn(), não há substituição da implementação original da função e queremos testar se, 
por exemplo, a função está sendo “chamada”, se está recebendo determinado parâmetro, etc. Nesse caso, 
apenas executar a função com jest.spyOn() ainda vai executar a função “original” e o código dentro dela. 
Porém, também é possível “mocar” (ou seja, substituir a implementação original de uma função).

https://jestjs.io/docs/jest-object#mock-functions

