https://node.js.org/pt-br/ 
https://www.docker.com/
https://github.com/nvm-sh/nvm#node-version-manager---
https://www.alura.com.br/artigos/descomplicando-o-trabalho-com-node
https://docs.npmjs.com/
https://yarnpkg.com/
https://www.markdownguide.org/getting-started/
https://www.alura.com.br/artigos/como-trabalhar-com-markdown
https://www.alura.com.br/artigos/guia-importacao-exportacao-modulos-javascript
https://www.npmjs.com/package/chalk


Gerenciadores

Gerenciadores de pacotes são repositórios de código aberto nos quais devs 
disponibilizam soluções para o uso da comunidade. Estas soluções nada mais são do que 
programas que outras pessoas desenvolveram e que utilizamos para ganhar tempo no 
desenvolvimento de nosso próprio código, e vão desde libs (bibliotecas) pequenas e 
específicas até frameworks com vários recursos prontos. E um pacote é como chamamos o 
conjunto do código que determinada lib ou framework utiliza para executar.

Módulos e pacotes
Um módulo serve para encapsular uma determinada funcionalidade, normalmente 
uma ou mais funções, “escondendo” sua implementação do restante da 
aplicação e expondo somente o necessário para seu uso - por meio de uma 
função que pode ser exportada para outras partes do código, por exemplo.

Dependências
Implica depender de algo. No caso, o programa que está sendo executado 
depende de outros para funcionar. Ou seja, usamos este termo para 
especificar quais são os pacotes dos quais um programa depende para 
funcionar. Então, quando falamos de dependências, estamos falando 
especificamente dos pacotes de terceiros que são utilizados por um 
programa.

----------------------------------------------------------------------------------

https://www.alura.com.br/artigos/async-await-no-javascript-o-que-e-e-quando-usar


Promise

Promessas podem ser concluídas de duas formas: fulfilled (realizada, completa) ou rejected 
(rejeitada), o que equivale a duas situações possíveis, ou a promessa se concretizou 
(retornou os dados ou executou o código que deveria) ou não.

Promessas que não estão fulfilled nem rejected estão pending (pendentes). Ou seja, ainda não é 
possível saber o resultado final porque o processamento ainda não foi concluído.

Após a finalização do processamento, a promessa passa para o estado de settled (concluída), 
independente do resultado.

Uma vez que a promessa está settled seu resultado não se altera mais. Ou seja, uma promessa que se 
concluiu como rejected não muda mais para o estado de fulfilled e vice-versa.

----------------------------------------------------------------------------------------

https://regex101.com/
https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Guide/Regular_Expressions
https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/RegExp
https://cursos.alura.com.br/course/expressoes-regulares
https://joi.dev/
https://www.npmjs.com/package/yup
https://joi.dev/tester/

----------------------------------------------------------------------------------------------

https://cursos.alura.com.br/course/linux-ubuntu
https://git-scm.com/
https://nodejs.org/api/errors.html

Errors no node

ENOTFOUND
Error: not found - Retorna quando o Node.js tenta estabelecer uma conexão com um servidor e a 
tentativa falha no DNS lookup; ou seja, ou o host não existe ou há algum erro no endereço fornecido, 
que não consegue ser resolvido pelo DNS.

Algumas das soluções possíveis: verifique se a URL fornecida realmente existe e se a string com a 
URL está sendo fornecida da forma correta para a função ou método que fará a conexão.

ENOENT
Error: no entity - Acontece quando um caminho especificado, seja um diretório ou um arquivo, não 
existe no sistema de arquivos. Neste caso, temos que verificar se o caminho fornecido está correto. 
Importante: algumas operações com fs requerem o uso do caminho absoluto de um arquivo ou diretório. 
Para “montar” a string com estes caminhos, você pode utilizar uma das libs mais comuns do Node.js, 
a path.

EISDIR
Error: is a directory - O caminho fornecido é um diretório. Normalmente vemos este erro quando o 
programa esperava receber um caminho de um arquivo, mas ao invés disso recebeu um diretório. 
Novamente, devemos verificar a string recebida pela função ou método para conferir se está completa 
e montada da forma correta.

ENOTDIR
Error: not a directory - é o contrário do erro anterior, quando o programa espera receber o caminho 
de um diretório mas recebe o caminho de um arquivo.

EADDRINUSE
Error: address already in use - Muitas vezes este erro acontece quando estamos iniciando ou 
reiniciando um servidor web. Ele indica que o servidor está tentando se conectar a uma porta lógica 
que já está sendo ocupada por outro programa.

ECONNREFUSED
Error: connection refused - Houve uma tentativa de envio de requisição a um endpoint, porém a conexão
foi recusada. Normalmente é causada por inatividade do serviço que está sendo requisitado.

ECONNRESET
Error: connection reset - Uma conexão em andamento foi fechada durante o processo de 
requisição-resposta, antes que a resposta fosse recebida. Pode ser causada por um timeout ou 
reinício do servidor.

-------------------------------------------------------------------------------------------------

https://devcenter.heroku.com/articles/cli-style-guide
https://blog.developer.atlassian.com/10-design-principles-for-delightful-clis/
https://nodejs.org/en/blog/release/v18.0.0/#fetch-experimental
http://gatinhosalsicha.com.br/
https://www.alura.com.br/artigos/desmistificando-o-protocolo-http-parte-1
https://docs.npmjs.com/cli/v7/commands/npm-run-script#description
https://www.npmjs.com/package/yargs
https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status
https://developer.mozilla.org/en-US/docs/Web/API/Response
https://docs.npmjs.com/cli/v7/configuring-npm/package-json
https://spdx.org/licenses/
https://www.npmjs.com/
https://semver.org/lang/pt-BR/
https://docs.npmjs.com/creating-and-publishing-scoped-public-packages

